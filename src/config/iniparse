#!/bin/dash
#
# Configuration file handler that supports a dialect of INI format.
#
# Depends on: path/normpath.awk
#
# Copyright 2022 Coastal Carolina University
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

usage() {
    cat << EOF
$0 [options] [[ini_file] ...]

Options:
    -h | --help
        Show this help message and exit.
    -i | --no-interpolation
        Disable variable interpolation.
    -m | --parameterized-sections
        Enable section parameterization.
    -o <directory> | --output <directory>
        Use <directory> for output instead of creating one with mktemp(1).
    -p section/key=value | --preload section/key=value
        Preload a value for a friendly name "key" in section "section" of the
        configuration file. If the section and slash are omitted, the variable
        will be an unsectioned global variable visible in all sections.
    -u | --no-underscores
        Do not convert spaces to underscores in section and key names when
        producing the output files and directories.

This program parses an INI file and produces a hierarchical output directory
containing the information from the file. Each section in the INI file
creates a directory in the output path, with the values from the INI file
exported to plain text files named according to the keys in each section. By
default, a new temporary directory is created, the path of which is output
after processing is finished. However, an existing directory may be specified
instead by using the -o option. Note that the directory specified with -o
must already exist and will not be created.

The supported dialect of INI supports full-line comments but not inline ones.
Line comments start with either # or ;. Values must NOT be quoted but may
contain spaces. Multi-line values are supported if subsequent lines are
indented at least to the level of the start of the value in the first line
(or one position after the = if the first line is blank). Section names
containing slashes will produce a hierarchy of subdirectories.

Basic variable substitution within the configuration system is supported
using the syntax \${key}, where key is another key in the configuration to
be replaced by a value wherever \${key} is used in a value. Preloaded values
for keys are supported by giving the -p option before each section/key=value
mapping. Any preloaded values set for keys that do not appear in the INI
file are written to the output directory as-is, while preloaded values for
keys that are present in the INI file will be overridden by the values
from the INI file.

Finally, it is worth noting the advantages of using an INI configuration
file as opposed to sourcing a configuration file made of shell code. First, a
configuration expressed in shell code that is sourced by the main script
becomes a potentially executable configuration, which does not enforce a
separation of mechanism and policy. Second, the INI format is a little
easier for most humans and read and write. This benefit is enhanced on Linux
systems, since many editors ship with syntax highlighting support for the INI
format already. With this script, one can produce a friendly user-facing INI
file, then process it into a directory hierarchy that is simple to use with
shell scripts.
EOF
}


self=$(readlink -e "$0")
whereami=$(dirname "${self}")
libteal_top=$(dirname "${whereami}")


preload=
output=
interpolation=1
parameterize=0
underscores=1

while [ $# -ne 0 ]; do
    case "$1" in
        -h|--help)
            usage
            exit 0
        ;;
        -i|--no-interpolation)
            interpolation=0
            shift
        ;;
        -m|--parameterized-sections)
            parameterize=1
            shift
        ;;
        -o|--output)
            output="$2"
            shift 2
        ;;
        -p|--preload)
            if echo "$2" | grep -q "="; then
                if [ -z "${preload}" ]; then
                    preload="$2"
                else
                    preload=$(printf "%s\n%s" "${preload}" "$2")
                fi
                shift 2
            else
                echo "Preload: not a section/name=value pair: <$2>" >&2
                exit 2
            fi
        ;;
        -u|--no-underscores)
            underscores=0
            shift
        ;;
        *)
            break
        ;;
    esac
done


# Resolve the output location
if [ -n "${output}" ]; then
    if [ ! -d "${output}" ]; then
        echo "Output directory does not exist: ${output}" >&2
        exit 1
    fi
else
    output=$(mktemp -d)
fi

echo "${output}"


# Create the preload file
preload_file=$(mktemp)
echo "${preload}" > "${preload_file}"


# Awk does the heavy lifting here
awk \
    -v interpolation=${interpolation} \
    -v parameterized_sections=${parameterize} \
    -v underscores=${underscores} \
    -v output_directory="${output}" \
    -f "${libteal_top}/path/cleanpath.awk" \
    -f "${whereami}/iniparse.awk" \
    -f "${whereami}/iniparse-output.awk" \
    "${preload_file}" \
    "$@"
#
status=$?

rm -f "${preload_file}"

exit ${status}
