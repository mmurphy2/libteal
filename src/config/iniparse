#!/bin/dash
#
# Configuration file handler that supports a dialect of INI format.
#
# Copyright 2022 Coastal Carolina University
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

usage() {
    cat << EOF
$0 [options] [-c <file>] [-m var=key] [-p key=value]

Options:
    -c <file> | --config <file>
        Read from the specified <file> instead of standard input.
    -h | --help
        Show this help message and exit.
    -m var=section.key | --map var=section.key
        Map the environment variable "var" to configuration file friendly
        name "key" in section "section".
    -n | --no-export
        Do not produce export statements for variables.
    -p section.key=value | --preload section.key=value
        Preload a value for a friendly name "key" in section "section" of the
        configuration file.
    -u | --error-unmapped
        Produce an error if the configuration file contains a key (friendly
        name) that is not mapped to an environment variable.

An example of the intended usage of iniparse is:

eval \$(iniparse -c /path/to/config.ini \\
    -m FOO="main.key 1" \\
    -m BAR="main.key 2")

In the above example, the value of the configuration key "key 1" in section
[main] of the configuration file will be mapped to environment variable FOO.
The value of the configuration key "key 2", also in section [main], will be
mapped to environment variable BAR.

The corresponding configuration file might look like this:
---
[main]
friendly = Hello
friendly 2 = World
---

The supported dialect of INI supports full-line comments but not inline ones.
Line comments start with either # or ;. Values must NOT be quoted but may
contain spaces. Multi-line values are supported if subsequent lines are
indented at least to the level of the start of the value in the first line
(or one position after the = if the first line is blank).

Basic variable substitution within the configuration system is supported
using the syntax \${key}, where key is another key in the configuration to
be replaced by a value wherever \${key} is used in a value. Preloaded values
for keys are supported by giving the -p option before each section.key=value
mapping. Any preloaded values set for keys that are mapped to environment
variables become the default values for those environment variables if the
key is missing from the configuration file. Thus, -p and -m can be used
together to permit a configuration file to supply optional overrides for an
existing value.

By default, all environment variable expressions generated by loadconfig are
followed by export statements. This behavior can be disabled with the -n
option. In addition, unmapped keys in the configuration file are typically
ignored. The -u option will cause any unmapped keys to produce an error.

Finally, it is worth noting the advantages over using an INI configuration
file as opposed to sourcing a configuration file made of shell code. First, a
configuration expressed in shell code that is sourced by the main script
becomes a potentially executable configuration, which does not enforce a
separation of mechanism and policy. Second, the INI format is a little
easier for most humans and read and write. This benefit is enhanced on Linux
systems, since many editors ship with syntax highlighting support for the INI
format already.
EOF
}


# concat_line <existing> <new_line>
#
# Concatenates <new_line> onto <existing> without producing extraneous empty lines in the
# resulting data.
concat_line() {
    if [ -n "$1" ]; then
        printf "%s\n%s" "$1" "$2"
    else
        echo "$2"
    fi
}


self=$(readlink -e "$0")
whereami=$(dirname "${self}")


config=
map=
opts=
preload=

while [ $# -ne 0 ]; do
    case "$1" in
        -c|--config)
            config="$2"
            shift 2
        ;;
        -h|--help)
            usage
            exit 0
        ;;
        -m|--map)
            if echo "$2" | grep -q '='; then
                map=$(concat_line "${map}" "$2")
                shift 2
            else
                echo "Not a section.name=value pair: $2" >&2
                exit 2
            fi
        ;;
        -n|--no-export)
            opts="${opts} noexport"
            shift
        ;;
        -p|--preload)
            if echo "$2" | grep -q "="; then
                preload=$(concat_line "${preload}" "$2")
                shift 2
            else
                echo "Not a section.name=value pair: <$2>" >&2
                exit 2
            fi
        ;;
        -u|--error-unmapped)
            opts="${opts} errunmapped"
            shift
        ;;
    esac
done


# When no config file is specified, read from standard input
if [ -z "${config}" ]; then
    cfgdata=$(cat)
else
    cfgdata=$(cat "${config}")
fi

data=$(printf '%s\n%s\n%s\n%s\n%s\n%s\n%s\n' \
    "${opts}" "${config}" "${preload}" "---" "${map}" "---" "${cfgdata}")
#

echo "${data}" | awk -f "${whereami}/iniparse.awk"
