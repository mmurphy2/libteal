#!/bin/dash
#
# TealPkg file resolver. Checks to see if a file is already available locally,
# and downloads the file from a remote server if it isn't. Optionally
# downloads and verifies the GPG signature associated with the file.
#
# Copyright 2022 Coastal Carolina University
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


usage() {
    cat << EOF
$0 [options] <URL | local_path> [output_path]

Options:
    -a <spec> | --detached-signature <spec>
        Controls the path to the detached GPG signature file. If <spec> is a
        URL or absolute path, then the GPG detached signature file is
        obtained from the specified location. If <spec> is a relative path,
        then the GPG detached signature file is obtained from the same path
        (local or remote) as the <URL>. Whenever a basename (final path
        component) is given that does NOT start with a period (.), the
        literal filename is used for the detached signature. If the basename
        begins with a period, then it is taken to be an extension that is
        appended to the <URL> to obtain the detached signature file. If the
        basename begins with .%, then the existing file extension (if any)
        is replaced by the specified extension. (If there is no existing
        extension, then the specified extension is appended to the filename.)
        The default <spec> is '.asc', which causes the signature to be
        obtained from <URL>.asc if -a is not specified.
    -g | --gpg
        Enable GPG signature checking.
    -G <directory> | --gpg-home <directory>
        Path to the GPG home directory for signature verification. By default,
        the --homedir option is not passed to gpg2 unless this option is
        given.
    -h | --help
        Show this help message and exit.
    -s <hash> | --check-hash <hash>
        Check the hash value of the file against the supplied value. The
        supplied value must be prefixed with the hash algorithm, followed by
        a colon (:). Supported hash algorithms are: md5, sha1, sha256,
        sha512, blake2-256, blake2-512.

Downloads the requested file from <URL>, saving it to [output_path]. if the
[output_path] is a directory, then the filename from the <URL> is used as
the destination file within the directory, unless the URL contains a rename
option in the form new_name::url. If [output_path] is not an existing
directory, and no rename option is prepended to the URL, then the
[output_path] is taken to be the literal destination of the file. When a
rename option and an [output_path] are both given, the [output_path] is
assumed to be the name of the output directory. If no [output_path] is
specified, the current working directory is used.

If the <URL> is a path to an existing local file on the filesystem, no
download is performed. Instead, the path is simply printed verbatim if it
can be resolved. Renaming is possible (with the :: rename option), in
which case a local copy is made.

Optionally, GPG verification can be performed using the gpg2 command. If
GPG verification is desired, then the -g or --gpg option must be given.The
the path to the GPG home directory containing the key(s) to be used for
verification may be specified with -G or --gpg-home option. It is assumed
that the detached GPG signature will be available from the remote server at
<URL>.asc by default. To change this assumption, give the -a
--detached-signature option as described above. For example:

-a '.sig'           # Changes the signature file to <URL>.sig
-a 'something.foo'  # Changes the signature file to <URL>/something.foo

The signature file may be located at a completely different remote
destination. For example, if the <URL> is https://example.org/file, then:

-a 'https://example.com/foo/.sig'

will obtain the detached signature from https://example.com/foo/file.sig
It is also possible to change the extension of a file completely. Thus,
if the <URL> is https://example.org/file.txt, then:

-a 'https://example.com/foo/.%sig'

will obtain the detached signature from https://example.com/foo/file.sig

In addition to (or instead of) GPG verification, hash-based verification is
available via the -s or --check-hash option. The hash digest (in hex format)
against which to check is supplied as an argument, with the hash algorithm
prefixed to the digest with a colon (:) to separate them. For example:

-s md5:fbfed4a936913947136b5fe13332a963

Exit status is 0 for a successful file resolution (including download and
verification), 1 if the download fails or a local file cannot be found,
3 if GPG verification fails, and 4 if hash verification fails. Upon
success, the absolute path to the resolved file is displayed on standard
output. Errors and progress information are sent to standard error.
EOF
}

gpgspec='.asc'
gpgcheck=
gpghome=
out_file=
check_hash=
hash_prog=
hash_name=

while [ $# -gt 0 ]; do
    case "$1" in
        -a|--detached-signature)
            gpgspec="$2"
            shift 2
        ;;
        -G|--gpg-home)
            gpghome="$2"
            shift 2
        ;;
        -g|--gpg)
            gpgcheck="on"
            shift
        ;;
        -h|--help)
            usage
            exit 0
        ;;
        -s|--check-hash)
            algorithm=$(echo "$2" | awk -F ':' '{print tolower($1)}')
            case "${algorithm}" in
                md5)
                    hash_prog="md5sum"
                    hash_name="MD5"
                ;;
                sha1)
                    hash_prog="sha1sum"
                    hash_name="SHA1"
                ;;
                sha256)
                    hash_prog="sha256sum"
                    hash_name="SHA256"
                ;;
                sha512)
                    hash_prog="sha512sum"
                    hash_name="SHA512"
                ;;
                blake2-256|b2-256)
                    hash_prog="b2sum -l 256"
                    hash_name="BLAKE2-256"
                ;;
                blake2-512|b2-512)
                    hash_prog="b2sum -l 512"
                    hash_name="BLAKE2-512"
                ;;
                *)
                    echo "Unsupported hash algorithm: ${algorithm}" >&2
                    exit 2
                ;;
            esac
            check_hash=$(echo "$2" | awk -F ':' '{print tolower($2)}')
            if [ -z "${check_hash}" ]; then
                echo "Missing hash digest after -s/--check-hash" >&2
                exit 2
            fi
            shift 2
        ;;
        *)
            break
        ;;
    esac
done


if [ $# -lt 1 -o $# -gt 2 ]; then
    echo "Usage: $0 [options] <URL | local_path> [output_path]" >&2
    exit 2
fi


url="$1"
out_path="$2"
[ -z "${out_path}" ] && out_path="."
rename_to=


# Check to see if we need to rename the download. In this case, the URL has the form
# newname::https://whatever, so split the pieces.
if echo "${url}" | grep -q '::'; then
    rename_to=$(echo "${url}" | awk -F '::' '{print $1}')
    url=$(echo "${url}" | awk -F '::' '{print $2}')
    if ! echo "${out_path}" | grep -q '/$'; then
        out_path="${out_path}/"
    fi
    out_path="${out_path}${rename_to}"

    # Go ahead and take care of file:// URLs here, so that we can copy instead of download later
    if echo "${url}" | grep -q '::/'; then
        scheme=$(awk -F '://' '{print tolower($1)}')
        if [ "x${scheme}" = "xfile" ]; then
            url=$(echo "${url}" | awk -F '::/' '{print $2}')
        fi
    fi
else
    # If NOT renaming, check to see if the user specified a local path, again to short-circuit
    # downloading or making a copy.
    if echo "${url}" | grep -q '::/'; then
        scheme=$(awk -F '::/' '{print tolower($1)}')
        if [ "x${scheme}" = "xfile" ]; then
            url=$(echo "${url}" | awk -F '::/' '{print $2}')
        fi
    fi

    # Fix up the destination filename if out_path is a directory
    if [ -d "${out_path}" ]; then
        out_file=$(basename "${url}")
        if ! echo "${out_path}" | grep -q '/$'; then
            out_path="${out_path}/"
        fi
        out_path="${out_path}${out_file}"
    fi
fi


# Quick sanity check:
parent=$(dirname "${out_path}")
if [ ! -d "${parent}" ]; then
    echo "Directory not found: ${parent}" >&2
    exit 1
fi


# If the file is not already available on the local system, resolve it.
have_file=
if [ ! -f "${out_path}" ]; then
    if echo "${url}" | grep -q '^/'; then
        # The source file is local: check for a rename
        if [ -n "${rename_to}" ]; then
            cp -v "${url}" "${out_path}" >&2 || exit 1
            have_file="${out_path}"
        else
            if [ ! -f "${url}" ]; then
                echo "File not found: ${url}" >&2
                exit 1
            fi
            echo "Found ${url}" >&2
            have_file="${url}"
        fi
    else
        remote_name=$(basename "${url}")
        echo "Downloading ${remote_name}..." >&2
        curl -o "${out_path}" "${url}" >&2 || exit 1
        have_file="${out_path}"
    fi
else
    have_file="${out_path}"
fi


# If GPG signature verification was requested, download the signature file (if necessary) and verify.
if [ -n "${gpgcheck}" ]; then
    # First, figure out if we're changing the extension or just appending to get the signature URL. Also
    # compute the output filename for the signature file.
    sigfile=
    sigurl=$(dirname "${url}")
    urlbase=$(basename "${url}")
    specpath=$(dirname "${gpgspec}")
    specbase=$(basename "${gpgspec}")
    outdir=$(dirname "${out_path}")
    outbase=$(basename "${have_file}")
    if echo "${specbase}" | grep -q '^\.%'; then
        suffix=$(echo "${specbase}" | sed 's/^\.%//')
        urlbase=$(echo "${urlbase}" | rev | cut -d '.' -f 2- | rev)
        outbase=$(echo "${outbase}" | rev | cut -d '.' -f 2- | rev)
        urlbase="${urlbase}.${suffix}"
        outbase="${outbase}.${suffix}"
    elif echo "${specbase}" | grep -q '^\.'; then
        suffix=$(echo "${specbase}" | sed 's/^\.//')
        urlbase="${urlbase}.${suffix}"
        outbase="${outbase}.${suffix}"
    else
        urlbase="${specbase}"
        outbase="${outbase}.asc"
    fi

    # Check to determine if the signature URL is on another host or in a different directory
    if echo "${specpath}" | grep -q '://'; then
        # On an entirely different host
        sigurl="${gpgspec}"
        sigfile="${outdir}/${outbase}"
    elif [ "${specpath}" != "." ]; then
        # Another directory on the same host
        if echo "${url}" | grep -q '://'; then
            if echo "${specpath}" | grep -q '^/'; then
                # Absolute path on a remote host: need to reassemble from the scheme and host parts of the URL
                scheme=$(echo "${url}" | awk -F '://' '{print $1}')
                host=$(echo "${url}" | awk -F '://' '{print $2}' | cut -d '/' -f 1)
                sigurl="${scheme}://${host}${specpath}/${specbase}"
                sigfile="${outdir}/${outbase}"
            else
                # A relative path on the remote host is relative to the current URL directory
                urlpath=$(dirname "${url}")
                sigurl="${urlpath}/${specpath}/${specbase}"
                sigfile="${outdir}/${outbase}"
            fi
        else
            if echo "${specpath}" | grep -q '^/'; then
                # Absolute path on the local file system
                sigurl=
                sigfile="${specpath}/${outbase}"
            else
                # Path relative to the url file (which is really a filename and not a URL at this point)
                urlpath=$(dirname "${url}")
                sigfile="${urlpath}/${specpath}/${outbase}"
                sigurl=
            fi
        fi
    else
        # Simple case: signature file is in the same directory as the original URL
        sigurl="${sigurl}/${urlbase}"
        sigfile="${out_path}/${outbase}"
        if [ "${have_file}" != "${out_path}" ]; then
            # The original file was on the local filesystem, so we expect the signature file to be there as well
            sigfile="${sigurl}"
        fi
    fi

    # Obtain the signature file, if necessary
    if [ ! -f "${sigfile}" ]; then
        if echo "${sigurl}" | grep -q '^/'; then
            # Local file: be sure it's there
            if [ -f "${sigurl}" ]; then
                if [ "${sigurl}" != "${sigfile}" ]; then
                    cp -v "${sigurl}" "${sigfile}" >&2 || exit 3
                fi
            else
                echo "GPG file not found: ${sigurl}" >&2
                exit 3
            fi
        else
            # Remote file
            echo "Downloading ${sigurl}..."
            curl -o "${sigfile}" "${sigurl}" >&2 || exit 3
        fi
    fi

    if [ -n "${gpghome}" ]; then
        gpg2 --homedir "${gpghome}" --verify "${sigfile}" "${have_file}" >&2
        result=$?
    else
        gpg2 --verify "${sigfile}" "${have_file}" >&2
        result=$?
    fi

    if [ ${result} -ne 0 ]; then
        echo "GPG verification failed: ${have_file}" >&2
        exit 3
    fi
fi


# If hash verification was requested, run the corresponding hash command against the download
if [ -n "${hash_prog}" ]; then
    the_hash=$(${hash_prog} "${have_file}")
    the_hash=$(echo "${the_hash}" | awk '{print tolower($1)}')
    if [ "x${check_hash}" != "x${the_hash}" ]; then
        echo "Hash verification failed: ${have_file}" >&2
        exit 4
    fi
    echo "OK: ${have_file} (${hash_name})" >&2
fi


# Success: output the resolved path
echo "${have_file}"
exit 0
